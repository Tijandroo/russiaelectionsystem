<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Roblox Election Voting</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* ... (keep all your existing CSS styles) ... */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #2c2c2c 0%, #1a1a1a 100%);
            color: #e0e0e0;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            width: 100%;
            background: rgba(40, 40, 40, 0.95);
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            border: 1px solid #444;
        }
        
        /* ... (keep ALL your existing CSS styles from before) ... */
    </style>
</head>
<body>
    <!-- Login Screen -->
    <div class="container">
        <div id="loginScreen" class="login-screen">
            <h1><i class="fab fa-roblox"></i> Roblox Election Voting</h1>
            <p>Please sign in with your Roblox account to vote in the election. You can only vote for one candidate, and your vote cannot be changed once submitted.</p>
            
            <button id="robloxLoginBtn" class="roblox-login-btn">
                <i class="fab fa-roblox"></i>
                Sign in with Roblox
            </button>
            
            <div class="login-info">
                <h3><i class="fas fa-shield-alt"></i> Secure Authentication</h3>
                <ul>
                    <li><i class="fas fa-check-circle"></i> Uses official Roblox OAuth 2.0</li>
                    <li><i class="fas fa-check-circle"></i> Your account information is protected</li>
                    <li><i class="fas fa-check-circle"></i> Only your username and avatar are accessed</li>
                    <li><i class="fas fa-check-circle"></i> One vote per Roblox account</li>
                </ul>
            </div>
            
            <div id="errorMessage" class="error-message">
                <h3><i class="fas fa-exclamation-triangle"></i> Error</h3>
                <p id="errorMessageText"></p>
            </div>
        </div>
        
        <!-- Loading Screen -->
        <div id="loadingScreen" class="loading-screen">
            <i class="fas fa-spinner fa-spin"></i>
            <h2>Authenticating with Roblox...</h2>
            <p>Please wait while we verify your account.</p>
        </div>
        
        <!-- Voting Screen (Hidden until login) -->
        <div id="votingScreen" class="voting-screen">
            <div class="user-header">
                <div class="user-info">
                    <div class="user-avatar">
                        <img id="loggedInAvatar" src="" alt="User Avatar">
                    </div>
                    <div class="user-details">
                        <h2 id="loggedInUsername">Username</h2>
                        <p id="loggedInUserId">ID: Loading...</p>
                    </div>
                </div>
                <button id="logoutBtn" class="logout-btn">
                    <i class="fas fa-sign-out-alt"></i> Logout
                </button>
            </div>
            
            <div class="voting-container">
                <div id="candidate-list" class="candidate-list">
                    <div class="loading">
                        <i class="fas fa-spinner fa-spin"></i>
                        <p>Loading candidates...</p>
                    </div>
                </div>
                
                <div class="results-panel">
                    <h2><i class="fas fa-chart-bar"></i> Current Results</h2>
                    <div id="results-container" class="results-container">
                        <div class="loading">
                            <i class="fas fa-spinner fa-spin"></i>
                            <p>Loading results...</p>
                        </div>
                    </div>
                    <div id="total-votes-element" class="total-votes">
                        <strong>0</strong> total votes cast
                    </div>
                    <div class="vote-info">
                        <p><i class="fas fa-info-circle"></i> Welcome! You can vote for one candidate only. Your vote cannot be changed.</p>
                    </div>
                </div>
            </div>
            
            <footer>
                <p>Roblox Election Voting System | Secure OAuth 2.0 Authentication | Votes are stored per account</p>
            </footer>
        </div>
    </div>
    
    <!-- Notification -->
    <div id="notification" class="notification">
        <div class="notification-content">
            <i class="fas fa-check-circle"></i>
            <span id="notification-text"></span>
        </div>
    </div>

    <script>
        // ============================================
        // CONFIGURATION - YOU MUST SET THESE VALUES
        // ============================================
        
        // Roblox Open Cloud OAuth Configuration
        // Get these from https://create.roblox.com/credentials
        const ROBLOX_CONFIG = {
            clientId: "YOUR_CLIENT_ID_HERE",           // Replace with your Client ID
            clientSecret: "YOUR_CLIENT_SECRET_HERE",   // Replace with your Client Secret
            redirectUri: window.location.origin + window.location.pathname,
            scopes: ["openid", "profile"]  // Required scopes
        };
        
        // Roblox Open Cloud API Endpoints
        const OPEN_CLOUD_ENDPOINTS = {
            // OAuth 2.0 Endpoints
            authorize: "https://apis.roblox.com/oauth/v1/authorize",
            token: "https://apis.roblox.com/oauth/v1/token",
            userInfo: "https://apis.roblox.com/oauth/v1/userinfo",
            revoke: "https://apis.roblox.com/oauth/v1/revoke",
            
            // Open Cloud APIs (Some are still in beta)
            usersApi: "https://apis.roblox.com/cloud/v2/users",  // Beta endpoint
            thumbnailsApi: "https://thumbnails.roblox.com/v1/users/avatar-headshot"
        };
        
        // IMPORTANT: Candidate Configuration
        // Since Open Cloud User API is limited, we need to configure candidates differently
        // You'll need to manually set up candidate data since we can't fetch by ID directly
        const CANDIDATES_CONFIG = [
            {
                id: "156",
                name: "Builderman (CEO)",
                username: "Builderman",
                description: "Founder & CEO of Roblox",
                // Use a known avatar URL or fallback
                avatarUrl: "https://tr.rbxcdn.com/bcdee8ac9a5a31a4759b448da7c9ff7e/150/150/AvatarHeadshot/Png"
            },
            {
                id: "261",
                name: "Telamon",
                username: "Telamon",
                description: "Community Manager",
                avatarUrl: "https://tr.rbxcdn.com/ed48128a86ab6cc04537207640f3e5a8/150/150/AvatarHeadshot/Png"
            },
            {
                id: "1134911",
                name: "Rukiryo",
                username: "Rukiryo",
                description: "Game Developer",
                avatarUrl: "https://tr.rbxcdn.com/9e7d0c3a4f81d4fa6864c5e755f1b150/150/150/AvatarHeadshot/Png"
            },
            {
                id: "3101665",
                name: "KreekCraft",
                username: "KreekCraft",
                description: "Popular Content Creator",
                avatarUrl: "https://tr.rbxcdn.com/0f0d1c30bb8c14136ab2a61baed35473/150/150/AvatarHeadshot/Png"
            },
            {
                id: "158415",
                name: "Sorcus",
                username: "Sorcus",
                description: "Game Developer",
                avatarUrl: "https://tr.rbxcdn.com/1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a/150/150/AvatarHeadshot/Png"
            }
            // Add more candidates with their known avatar URLs
        ];
        
        // For avatar fallbacks when Open Cloud API fails
        const AVATAR_FALLBACKS = {
            "156": "https://tr.rbxcdn.com/bcdee8ac9a5a31a4759b448da7c9ff7e/150/150/AvatarHeadshot/Png",
            "261": "https://tr.rbxcdn.com/ed48128a86ab6cc04537207640f3e5a8/150/150/AvatarHeadshot/Png",
            "1134911": "https://tr.rbxcdn.com/9e7d0c3a4f81d4fa6864c5e755f1b150/150/150/AvatarHeadshot/Png",
            "3101665": "https://tr.rbxcdn.com/0f0d1c30bb8c14136ab2a61baed35473/150/150/AvatarHeadshot/Png",
            "158415": "https://tr.rbxcdn.com/1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a/150/150/AvatarHeadshot/Png"
        };
    </script>

    <script>
        // ============================================
        // Voting System with Roblox Open Cloud OAuth
        // ============================================
        
        class VotingSystem {
            constructor() {
                this.candidates = [];
                this.currentUser = null;
                this.accessToken = null;
                this.init();
            }
            
            init() {
                // Set up event listeners
                document.getElementById('robloxLoginBtn').addEventListener('click', () => this.initiateOAuthFlow());
                document.getElementById('logoutBtn').addEventListener('click', () => this.logout());
                
                // Check for OAuth callback
                this.handleOAuthCallback();
                
                // Check if user is already logged in
                const savedUser = localStorage.getItem('roblox_user');
                const savedToken = localStorage.getItem('roblox_token');
                
                if (savedUser && savedToken) {
                    this.currentUser = JSON.parse(savedUser);
                    this.accessToken = savedToken;
                    this.showVotingScreen();
                }
                
                // Load candidates from configuration (not API due to CORS)
                this.loadCandidatesFromConfig();
            }
            
            // Load candidates from configuration instead of API
            loadCandidatesFromConfig() {
                this.candidates = CANDIDATES_CONFIG.map(candidate => {
                    return {
                        ...candidate,
                        votes: parseInt(localStorage.getItem(`votes_${candidate.id}`)) || 0,
                        userVoted: false // Will be updated when user logs in
                    };
                });
                
                this.renderCandidates();
                this.renderResults();
            }
            
            // Optional: Try to fetch candidate avatars through Open Cloud (if you have API key)
            async tryFetchCandidateAvatars() {
                // This requires an Open Cloud API Key with proper permissions
                // Currently limited in functionality
                for (const candidate of this.candidates) {
                    try {
                        // Note: Open Cloud API for users is limited and may require different authentication
                        // This is a placeholder for when the API becomes more accessible
                        const avatarUrl = `https://thumbnails.roblox.com/v1/users/avatar-headshot?userIds=${candidate.id}&size=150x150&format=Png&isCircular=false`;
                        
                        // Try to fetch - may still have CORS issues
                        const response = await fetch(avatarUrl);
                        if (response.ok) {
                            const data = await response.json();
                            if (data.data && data.data[0]) {
                                candidate.avatarUrl = data.data[0].imageUrl;
                            }
                        }
                    } catch (error) {
                        console.log(`Using configured avatar for ${candidate.name}`);
                        // Keep the configured avatar URL
                    }
                }
                
                this.renderCandidates();
            }
            
            // OAuth 2.0 Flow Methods
            initiateOAuthFlow() {
                // Check if configuration is set
                if (ROBLOX_CONFIG.clientId === "YOUR_CLIENT_ID_HERE" || ROBLOX_CONFIG.clientSecret === "YOUR_CLIENT_SECRET_HERE") {
                    this.showError("Please configure the Roblox OAuth credentials in the script. Replace YOUR_CLIENT_ID_HERE and YOUR_CLIENT_SECRET_HERE with your actual credentials from https://create.roblox.com/credentials");
                    return;
                }
                
                // Generate state parameter for security
                const state = this.generateRandomString(16);
                localStorage.setItem('oauth_state', state);
                
                // Build authorization URL for Open Cloud OAuth
                const authUrl = new URL(OPEN_CLOUD_ENDPOINTS.authorize);
                authUrl.searchParams.append('client_id', ROBLOX_CONFIG.clientId);
                authUrl.searchParams.append('redirect_uri', ROBLOX_CONFIG.redirectUri);
                authUrl.searchParams.append('response_type', 'code');
                authUrl.searchParams.append('scope', ROBLOX_CONFIG.scopes.join(' '));
                authUrl.searchParams.append('state', state);
                
                // Redirect to Roblox Open Cloud OAuth
                window.location.href = authUrl.toString();
            }
            
            handleOAuthCallback() {
                const urlParams = new URLSearchParams(window.location.search);
                const code = urlParams.get('code');
                const state = urlParams.get('state');
                const error = urlParams.get('error');
                
                if (error) {
                    this.showError(`OAuth Error: ${error}`);
                    return;
                }
                
                if (code && state) {
                    // Verify state to prevent CSRF
                    const savedState = localStorage.getItem('oauth_state');
                    if (state !== savedState) {
                        this.showError("Security error: State mismatch");
                        return;
                    }
                    
                    // Show loading screen
                    this.showLoadingScreen();
                    
                    // Exchange code for tokens using Open Cloud endpoint
                    this.exchangeCodeForTokens(code);
                    
                    // Clean up URL
                    window.history.replaceState({}, document.title, window.location.pathname);
                }
            }
            
            async exchangeCodeForTokens(code) {
                try {
                    // IMPORTANT: Token exchange MUST happen server-side in production
                    // This client-side example is for demonstration only
                    // In production, you need a backend server
                    
                    const tokenData = new URLSearchParams();
                    tokenData.append('client_id', ROBLOX_CONFIG.clientId);
                    tokenData.append('client_secret', ROBLOX_CONFIG.clientSecret);
                    tokenData.append('grant_type', 'authorization_code');
                    tokenData.append('code', code);
                    tokenData.append('redirect_uri', ROBLOX_CONFIG.redirectUri);
                    
                    // WARNING: This exposes client secret in frontend code
                    // This should ONLY be used for testing/demo purposes
                    // For production, implement a backend server
                    const response = await fetch(OPEN_CLOUD_ENDPOINTS.token, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded'
                        },
                        body: tokenData
                    });
                    
                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`Token exchange failed: ${response.status} - ${errorText}`);
                    }
                    
                    const tokens = await response.json();
                    this.accessToken = tokens.access_token;
                    
                    // Get user info from Open Cloud OAuth endpoint
                    await this.fetchOpenCloudUserInfo();
                    
                } catch (error) {
                    console.error('Token exchange error:', error);
                    this.showError('Failed to authenticate with Roblox. Please try again. Error: ' + error.message);
                    this.showLoginScreen();
                }
            }
            
            async fetchOpenCloudUserInfo() {
                try {
                    // Fetch user info from Open Cloud OAuth userinfo endpoint
                    const response = await fetch(OPEN_CLOUD_ENDPOINTS.userInfo, {
                        headers: {
                            'Authorization': `Bearer ${this.accessToken}`
                        }
                    });
                    
                    if (!response.ok) {
                        throw new Error(`User info fetch failed: ${response.status}`);
                    }
                    
                    const userInfo = await response.json();
                    
                    // Get user avatar using Open Cloud thumbnails API (works with CORS)
                    let avatarUrl = AVATAR_FALLBACKS[userInfo.sub] || `https://via.placeholder.com/150/00a2ff/ffffff?text=${userInfo.preferred_username?.charAt(0) || 'U'}`;
                    
                    try {
                        // Try to get actual avatar from Open Cloud thumbnails API
                        const avatarResponse = await fetch(`${OPEN_CLOUD_ENDPOINTS.thumbnailsApi}?userIds=${userInfo.sub}&size=150x150&format=Png&isCircular=true`);
                        if (avatarResponse.ok) {
                            const avatarData = await avatarResponse.json();
                            if (avatarData.data && avatarData.data[0]) {
                                avatarUrl = avatarData.data[0].imageUrl;
                            }
                        }
                    } catch (avatarError) {
                        console.log('Using fallback avatar:', avatarError);
                    }
                    
                    // Store user data
                    this.currentUser = {
                        id: userInfo.sub,
                        username: userInfo.preferred_username || 'Roblox User',
                        displayName: userInfo.name || userInfo.preferred_username || 'Roblox User',
                        avatarUrl: avatarUrl
                    };
                    
                    // Save to localStorage
                    localStorage.setItem('roblox_user', JSON.stringify(this.currentUser));
                    localStorage.setItem('roblox_token', this.accessToken);
                    
                    // Show voting screen
                    this.showVotingScreen();
                    this.showNotification(`Welcome, ${this.currentUser.username}!`);
                    
                } catch (error) {
                    console.error('Error fetching user info:', error);
                    this.showError('Failed to load user information. Please try again.');
                    this.showLoginScreen();
                }
            }
            
            logout() {
                if (confirm('Are you sure you want to logout?')) {
                    // Clear user data
                    this.currentUser = null;
                    this.accessToken = null;
                    localStorage.removeItem('roblox_user');
                    localStorage.removeItem('roblox_token');
                    localStorage.removeItem('oauth_state');
                    
                    // Clear user votes from candidates
                    this.candidates.forEach(candidate => {
                        candidate.userVoted = false;
                    });
                    
                    // Show login screen
                    this.showLoginScreen();
                    this.renderCandidates();
                    this.showNotification('Successfully logged out.');
                }
            }
            
            vote(candidateId) {
                if (!this.currentUser) {
                    this.showNotification("Please login to vote.");
                    return;
                }
                
                // Check if user already voted for any candidate
                const userVotes = JSON.parse(localStorage.getItem(`user_votes_${this.currentUser.id}`)) || [];
                if (userVotes.length > 0) {
                    this.showNotification("You have already voted! You can only vote for one candidate.");
                    return;
                }
                
                // Find candidate and update votes
                const candidate = this.candidates.find(c => c.id === candidateId);
                if (!candidate) return;
                
                // Update vote count
                candidate.votes++;
                candidate.userVoted = true;
                
                // Save candidate votes
                localStorage.setItem(`votes_${candidateId}`, candidate.votes.toString());
                
                // Save user's vote
                userVotes.push(candidateId);
                localStorage.setItem(`user_votes_${this.currentUser.id}`, JSON.stringify(userVotes));
                
                // Update UI
                this.renderCandidates();
                this.renderResults();
                
                // Show notification
                this.showNotification(`âœ… You voted for ${candidate.name}!`);
            }
            
            // UI Management Methods
            showLoginScreen() {
                document.getElementById('loginScreen').style.display = 'block';
                document.getElementById('loadingScreen').style.display = 'none';
                document.getElementById('votingScreen').style.display = 'none';
            }
            
            showLoadingScreen() {
                document.getElementById('loginScreen').style.display = 'none';
                document.getElementById('loadingScreen').style.display = 'block';
                document.getElementById('votingScreen').style.display = 'none';
            }
            
            showVotingScreen() {
                document.getElementById('loginScreen').style.display = 'none';
                document.getElementById('loadingScreen').style.display = 'none';
                document.getElementById('votingScreen').style.display = 'block';
                
                // Update user info display
                if (this.currentUser) {
                    document.getElementById('loggedInUsername').textContent = this.currentUser.username;
                    document.getElementById('loggedInUserId').textContent = `ID: ${this.currentUser.id}`;
                    document.getElementById('loggedInAvatar').src = this.currentUser.avatarUrl;
                    
                    // Load user's vote status
                    this.loadUserVoteStatus();
                }
            }
            
            loadUserVoteStatus() {
                if (!this.currentUser) return;
                
                const userVotes = JSON.parse(localStorage.getItem(`user_votes_${this.currentUser.id}`)) || [];
                
                // Update candidates with user's vote status
                this.candidates.forEach(candidate => {
                    candidate.userVoted = userVotes.includes(candidate.id);
                });
                
                this.renderCandidates();
            }
            
            hasUserVoted() {
                if (!this.currentUser) return false;
                const userVotes = JSON.parse(localStorage.getItem(`user_votes_${this.currentUser.id}`)) || [];
                return userVotes.length > 0;
            }
            
            showNotification(message) {
                const notification = document.getElementById('notification');
                const notificationText = document.getElementById('notification-text');
                
                notificationText.textContent = message;
                notification.classList.add('show');
                
                // Hide after 5 seconds
                setTimeout(() => {
                    notification.classList.remove('show');
                }, 5000);
            }
            
            showError(message) {
                const errorDiv = document.getElementById('errorMessage');
                const errorText = document.getElementById('errorMessageText');
                
                errorText.textContent = message;
                errorDiv.style.display = 'block';
                
                // Auto-hide after 10 seconds
                setTimeout(() => {
                    errorDiv.style.display = 'none';
                }, 10000);
            }
            
            renderCandidates() {
                const container = document.getElementById('candidate-list');
                
                if (this.candidates.length === 0) {
                    container.innerHTML = '<div class="loading"><i class="fas fa-exclamation-triangle"></i><p>No candidates available. Check configuration.</p></div>';
                    return;
                }
                
                container.innerHTML = this.candidates.map(candidate => {
                    const hasVotedForThis = candidate.userVoted;
                    const canVote = this.currentUser && !this.hasUserVoted();
                    
                    return `
                        <div class="candidate-card ${hasVotedForThis ? 'voted' : ''}">
                            ${hasVotedForThis ? '<div class="vote-check"><i class="fas fa-check"></i></div>' : ''}
                            
                            <div class="avatar-container">
                                <img src="${candidate.avatarUrl}" alt="${candidate.name}" class="avatar-img"
                                     onerror="this.onerror=null; this.src='https://via.placeholder.com/150/00a2ff/ffffff?text=${candidate.name.charAt(0)}'">
                            </div>
                            
                            <h3 class="candidate-name">${candidate.name}</h3>
                            <p class="candidate-username">@${candidate.username}</p>
                            <p class="candidate-id">ID: ${candidate.id}</p>
                            <p class="candidate-description">${candidate.description}</p>
                            
                            <div class="vote-count">${candidate.votes} votes</div>
                            
                            <button class="vote-btn ${hasVotedForThis ? 'voted' : ''}" 
                                    onclick="votingSystem.vote('${candidate.id}')"
                                    ${!this.currentUser || this.hasUserVoted() ? 'disabled' : ''}>
                                ${hasVotedForThis ? '<i class="fas fa-check"></i> Voted' : 
                                  !this.currentUser ? 'Login to Vote' : 
                                  this.hasUserVoted() ? 'Already Voted' : '<i class="fas fa-vote-yea"></i> Vote Now'}
                            </button>
                        </div>
                    `;
                }).join('');
            }
            
            renderResults() {
                const container = document.getElementById('results-container');
                const totalVotesEl = document.getElementById('total-votes-element');
                
                // Sort by votes (descending)
                const sorted = [...this.candidates].sort((a, b) => b.votes - a.votes);
                
                // Calculate total votes
                const totalVotes = sorted.reduce((sum, candidate) => sum + candidate.votes, 0);
                
                // Find max votes for percentage calculation
                const maxVotes = sorted.length > 0 ? Math.max(...sorted.map(c => c.votes)) : 0;
                
                container.innerHTML = sorted.map(candidate => {
                    const percentage = maxVotes > 0 ? (candidate.votes / maxVotes) * 100 : 0;
                    const totalPercentage = totalVotes > 0 ? ((candidate.votes / totalVotes) * 100).toFixed(1) : 0;
                    
                    return `
                        <div class="result-item">
                            <div class="result-name">${candidate.name}</div>
                            <div class="result-votes">${candidate.votes} votes (${totalPercentage}%)</div>
                            <div class="result-bar">
                                <div class="result-fill" style="width: ${percentage}%"></div>
                            </div>
                        </div>
                    `;
                }).join('');
                
                if (totalVotesEl) {
                    totalVotesEl.innerHTML = `<strong>${totalVotes}</strong> total votes cast`;
                }
            }
            
            generateRandomString(length) {
                const charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
                let result = '';
                for (let i = 0; i < length; i++) {
                    result += charset.charAt(Math.floor(Math.random() * charset.length));
                }
                return result;
            }
        }
        
        // Initialize the voting system
        let votingSystem;
        
        document.addEventListener('DOMContentLoaded', () => {
            votingSystem = new VotingSystem();
        });
        
        // Make system accessible globally
        window.votingSystem = votingSystem;
    </script>
</body>
</html>
